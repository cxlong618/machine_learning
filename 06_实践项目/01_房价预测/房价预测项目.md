# 🏠 房价预测项目完整指南

## 📋 项目概述

### 项目目标
构建一个能够预测房屋价格的机器学习模型，帮助用户基于房屋特征来估算房价。

### 技术栈
- **Python**: 主要编程语言
- **Pandas**: 数据处理
- **NumPy**: 数值计算
- **Scikit-learn**: 机器学习算法
- **Matplotlib/Seaborn**: 数据可视化
- **Streamlit**: Web应用部署

## 🛠️ 环境准备

### 1. 安装依赖
```bash
pip install pandas numpy scikit-learn matplotlib seaborn streamlit
```

### 2. 项目结构
```
房价预测项目/
├── data/                   # 数据文件
│   ├── housing.csv        # 房价数据集
│   └── sample_submission.csv
├── notebooks/             # Jupyter笔记本
│   ├── 01_数据探索.ipynb
│   ├── 02_特征工程.ipynb
│   └── 03_模型训练.ipynb
├── src/                   # 源代码
│   ├── data_processing.py
│   ├── feature_engineering.py
│   ├── model_training.py
│   └── prediction.py
├── models/               # 保存的模型
├── app.py               # Streamlit应用
├── requirements.txt     # 依赖列表
└── README.md           # 项目说明
```

## 📊 数据探索与分析

### 1. 数据集介绍
使用加州房价数据集（California Housing Dataset）

**特征说明**：
- `longitude`: 经度
- `latitude`: 纬度
- `housing_median_age`: 房屋年龄中位数
- `total_rooms`: 总房间数
- `total_bedrooms`: 总卧室数
- `population`: 人口数
- `households`: 家庭数
- `median_income`: 收入中位数
- `median_house_value`: 房价中位数（目标变量）

### 2. 数据探索代码

```python
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# 加载数据
def load_data():
    """加载房价数据集"""
    # 使用sklearn内置的加州房价数据集
    from sklearn.datasets import fetch_california_housing
    housing = fetch_california_housing()

    # 创建DataFrame
    df = pd.DataFrame(housing.data, columns=housing.feature_names)
    df['target'] = housing.target

    return df

# 基础数据探索
def basic_exploration(df):
    """基础数据探索"""
    print("数据基本信息:")
    print(f"数据形状: {df.shape}")
    print(f"特征数量: {df.shape[1] - 1}")

    print("\n数据类型:")
    print(df.dtypes)

    print("\n缺失值统计:")
    print(df.isnull().sum())

    print("\n描述性统计:")
    print(df.describe())

    return df

# 可视化分析
def visualize_data(df):
    """数据可视化分析"""
    # 设置中文显示
    plt.rcParams['font.sans-serif'] = ['SimHei']
    plt.rcParams['axes.unicode_minus'] = False

    # 创建子图
    fig, axes = plt.subplots(2, 3, figsize=(18, 12))

    # 1. 目标变量分布
    axes[0, 0].hist(df['target'], bins=30, alpha=0.7)
    axes[0, 0].set_title('房价分布')
    axes[0, 0].set_xlabel('房价')
    axes[0, 0].set_ylabel('频次')

    # 2. 收入与房价关系
    axes[0, 1].scatter(df['MedInc'], df['target'], alpha=0.5)
    axes[0, 1].set_title('收入 vs 房价')
    axes[0, 1].set_xlabel('收入中位数')
    axes[0, 1].set_ylabel('房价')

    # 3. 房屋年龄与房价关系
    axes[0, 2].scatter(df['HouseAge'], df['target'], alpha=0.5)
    axes[0, 2].set_title('房屋年龄 vs 房价')
    axes[0, 2].set_xlabel('房屋年龄')
    axes[0, 2].set_ylabel('房价')

    # 4. 地理位置分布
    axes[1, 0].scatter(df['Longitude'], df['Latitude'],
                      c=df['target'], cmap='viridis', alpha=0.5)
    axes[1, 0].set_title('房价地理分布')
    axes[1, 0].set_xlabel('经度')
    axes[1, 0].set_ylabel('纬度')

    # 5. 相关性热力图
    correlation_matrix = df.corr()
    sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm',
               center=0, ax=axes[1, 1])
    axes[1, 1].set_title('特征相关性')

    # 6. 房间数与房价关系
    axes[1, 2].scatter(df['AveRooms'], df['target'], alpha=0.5)
    axes[1, 2].set_title('平均房间数 vs 房价')
    axes[1, 2].set_xlabel('平均房间数')
    axes[1, 2].set_ylabel('房价')

    plt.tight_layout()
    plt.savefig('data_exploration.png', dpi=300, bbox_inches='tight')
    plt.show()

# 运行探索
if __name__ == "__main__":
    df = load_data()
    df = basic_exploration(df)
    visualize_data(df)
```

## ⚙️ 特征工程

```python
from sklearn.preprocessing import StandardScaler, PolynomialFeatures
from sklearn.model_selection import train_test_split

class FeatureEngineering:
    def __init__(self):
        self.scaler = StandardScaler()
        self.poly_features = PolynomialFeatures(degree=2, include_bias=False)

    def create_features(self, df):
        """创建新特征"""
        df_new = df.copy()

        # 1. 房间密度特征
        df_new['rooms_per_household'] = df_new['AveRooms']
        df_new['bedrooms_per_room'] = df_new['AveBedrms'] / df_new['AveRooms']
        df_new['population_per_household'] = df_new['Population'] / df_new['Households']

        # 2. 位置特征组合
        df_new['location_score'] = np.sqrt(df_new['Latitude']**2 + df_new['Longitude']**2)

        # 3. 收入等级特征
        df_new['income_level'] = pd.cut(df_new['MedInc'],
                                       bins=[0, 2, 4, 6, np.inf],
                                       labels=['低收入', '中等收入', '高收入', '很高收入'])

        # 4. 房屋年龄分组
        df_new['age_group'] = pd.cut(df_new['HouseAge'],
                                    bins=[0, 10, 25, 35, np.inf],
                                    labels=['新房', '中等房龄', '老房', '很老的房子'])

        # 5. 收入与年龄交互特征
        df_new['income_age_interaction'] = df_new['MedInc'] * df_new['HouseAge']

        return df_new

    def preprocess_data(self, df, test_size=0.2, random_state=42):
        """数据预处理"""
        # 分离特征和目标
        X = df.drop('target', axis=1)
        y = df['target']

        # 处理分类特征
        categorical_features = ['income_level', 'age_group']
        X_encoded = pd.get_dummies(X, columns=categorical_features, drop_first=True)

        # 分割数据
        X_train, X_test, y_train, y_test = train_test_split(
            X_encoded, y, test_size=test_size, random_state=random_state
        )

        # 标准化数值特征
        numerical_features = X_encoded.select_dtypes(include=[np.number]).columns.tolist()

        X_train[numerical_features] = self.scaler.fit_transform(X_train[numerical_features])
        X_test[numerical_features] = self.scaler.transform(X_test[numerical_features])

        return X_train, X_test, y_train, y_test
```

## 🤖 模型训练与评估

```python
from sklearn.linear_model import LinearRegression, Ridge, Lasso
from sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressor
from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error
import joblib

class ModelTrainer:
    def __init__(self):
        self.models = {}
        self.best_model = None
        self.best_score = float('-inf')

    def train_models(self, X_train, y_train):
        """训练多个模型"""
        models_config = {
            'Linear Regression': LinearRegression(),
            'Ridge Regression': Ridge(alpha=1.0),
            'Lasso Regression': Lasso(alpha=0.1),
            'Random Forest': RandomForestRegressor(n_estimators=100, random_state=42),
            'Gradient Boosting': GradientBoostingRegressor(n_estimators=100, random_state=42)
        }

        for name, model in models_config.items():
            print(f"训练 {name}...")
            model.fit(X_train, y_train)
            self.models[name] = model

    def evaluate_models(self, X_test, y_test):
        """评估模型性能"""
        results = {}

        for name, model in self.models.items():
            y_pred = model.predict(X_test)

            # 计算评估指标
            mse = mean_squared_error(y_test, y_pred)
            rmse = np.sqrt(mse)
            mae = mean_absolute_error(y_test, y_pred)
            r2 = r2_score(y_test, y_pred)

            results[name] = {
                'MSE': mse,
                'RMSE': rmse,
                'MAE': mae,
                'R2': r2
            }

            # 更新最佳模型
            if r2 > self.best_score:
                self.best_score = r2
                self.best_model = model
                self.best_model_name = name

        # 打印结果
        print("\n模型评估结果:")
        print("-" * 60)
        print(f"{'模型':<20} {'RMSE':<10} {'MAE':<10} {'R²':<10}")
        print("-" * 60)

        for name, metrics in results.items():
            print(f"{name:<20} {metrics['RMSE']:<10.4f} {metrics['MAE']:<10.4f} {metrics['R2']:<10.4f}")

        print(f"\n最佳模型: {self.best_model_name} (R² = {self.best_score:.4f})")

        return results

    def feature_importance(self, X_train):
        """分析特征重要性"""
        if hasattr(self.best_model, 'feature_importances_'):
            importances = self.best_model.feature_importances_
            feature_names = X_train.columns

            # 创建特征重要性DataFrame
            feature_df = pd.DataFrame({
                'feature': feature_names,
                'importance': importances
            }).sort_values('importance', ascending=False)

            # 可视化特征重要性
            plt.figure(figsize=(10, 8))
            top_features = feature_df.head(15)
            plt.barh(range(len(top_features)), top_features['importance'])
            plt.yticks(range(len(top_features)), top_features['feature'])
            plt.xlabel('特征重要性')
            plt.title(f'{self.best_model_name} - 特征重要性')
            plt.gca().invert_yaxis()
            plt.tight_layout()
            plt.savefig('feature_importance.png', dpi=300, bbox_inches='tight')
            plt.show()

            return feature_df

    def save_model(self, filename='best_model.pkl'):
        """保存最佳模型"""
        joblib.dump(self.best_model, filename)
        print(f"模型已保存为 {filename}")

    def load_model(self, filename='best_model.pkl'):
        """加载模型"""
        self.best_model = joblib.load(filename)
        return self.best_model
```

## 📱 Web应用开发

```python
import streamlit as st
import pandas as pd
import numpy as np
import joblib
from src.feature_engineering import FeatureEngineering

# 页面配置
st.set_page_config(
    page_title="房价预测系统",
    page_icon="🏠",
    layout="wide"
)

# 标题和描述
st.title("🏠 加州房价预测系统")
st.markdown("""
这个系统使用机器学习算法来预测加州房屋的价格。
请输入房屋的特征信息，系统将给出预测价格。
""")

# 加载模型和预处理器
@st.cache_resource
def load_model_and_preprocessor():
    try:
        model = joblib.load('models/best_model.pkl')
        fe = FeatureEngineering()
        # 这里需要保存并加载scaler
        return model, fe
    except FileNotFoundError:
        st.error("模型文件未找到，请先训练模型")
        return None, None

# 侧边栏输入
st.sidebar.header("房屋特征信息")

def user_input_features():
    """获取用户输入"""
    # 收入信息
    med_inc = st.sidebar.slider("收入中位数", 0.5, 15.0, 3.5)

    # 房屋信息
    house_age = st.sidebar.slider("房屋年龄", 1, 52, 25)
    ave_rooms = st.sidebar.slider("平均房间数", 1.0, 10.0, 5.5)
    ave_bedrms = st.sidebar.slider("平均卧室数", 0.5, 7.0, 1.1)

    # 人口信息
    population = st.sidebar.slider("人口数", 3, 35682, 1425)
    households = st.sidebar.slider("家庭数", 2, 6082, 499)

    # 地理位置信息
    longitude = st.sidebar.slider("经度", -124.0, -114.0, -118.0)
    latitude = st.sidebar.slider("纬度", 32.0, 42.0, 34.0)

    # 创建特征字典
    features = {
        'MedInc': med_inc,
        'HouseAge': house_age,
        'AveRooms': ave_rooms,
        'AveBedrms': ave_bedrms,
        'Population': population,
        'AveOccup': population / households,
        'Latitude': latitude,
        'Longitude': longitude
    }

    return pd.DataFrame([features])

# 主程序
def main():
    # 加载模型
    model, fe = load_model_and_preprocessor()

    if model is None:
        st.stop()

    # 获取用户输入
    input_df = user_input_features()

    # 显示输入信息
    st.subheader("输入的房屋特征")
    st.write(input_df)

    # 预测按钮
    if st.button("预测房价"):
        # 特征工程
        processed_df = fe.create_features(input_df)

        # 这里需要确保特征顺序和训练时一致
        # 预测
        prediction = model.predict(processed_df)

        # 显示结果
        st.subheader("预测结果")

        # 主要预测结果
        col1, col2, col3 = st.columns(3)

        with col1:
            st.metric(
                label="预测房价",
                value=f"${prediction[0]*100000:,.0f}",
                delta=""
            )

        with col2:
            # 价格区间估算（假设±10%误差）
            lower_bound = prediction[0] * 100000 * 0.9
            upper_bound = prediction[0] * 100000 * 1.1
            st.metric(
                label="价格区间",
                value=f"${lower_bound:,.0f} - ${upper_bound:,.0f}",
                delta=""
            )

        with col3:
            # 价格等级
            if prediction[0] < 2:
                price_level = "低档"
                color = "🟢"
            elif prediction[0] < 4:
                price_level = "中档"
                color = "🟡"
            else:
                price_level = "高档"
                color = "🔴"

            st.metric(
                label="价格等级",
                value=f"{color} {price_level}",
                delta=""
            )

        # 详细分析
        st.subheader("详细分析")

        # 价格分布图
        fig, ax = plt.subplots(figsize=(10, 6))

        # 生成一些示例数据来显示分布
        sample_prices = np.random.normal(prediction[0], 0.5, 1000)
        ax.hist(sample_prices, bins=30, alpha=0.7, color='skyblue')
        ax.axvline(prediction[0], color='red', linestyle='--', linewidth=2, label='预测价格')
        ax.set_xlabel('房价（单位：10万美元）')
        ax.set_ylabel('频次')
        ax.set_title('预测价格分布')
        ax.legend()

        st.pyplot(fig)

        # 特征影响分析
        st.subheader("特征影响分析")

        # 这里可以添加SHAP值或其他解释性分析
        st.info("""
        **主要影响因素**:
        - 收入水平是影响房价的最重要因素
        - 地理位置也对房价有显著影响
        - 房屋的新旧程度和大小也是重要考量因素
        """)

        # 比较分析
        st.subheader("市场比较")

        # 与平均价格比较
        avg_price = 2.07  # 假设的平均房价
        price_diff = prediction[0] - avg_price
        price_diff_pct = (price_diff / avg_price) * 100

        col1, col2 = st.columns(2)

        with col1:
            if price_diff > 0:
                st.success(f"比市场均价高 ${price_diff*100000:,.0f} ({price_diff_pct:.1f}%)")
            else:
                st.warning(f"比市场均价低 ${abs(price_diff)*100000:,.0f} ({abs(price_diff_pct):.1f}%)")

        with col2:
            st.metric(
                "市场均价",
                f"${avg_price*100000:,.0f}",
                f"{price_diff_pct:+.1f}%"
            )

if __name__ == "__main__":
    main()
```

## 🎯 项目执行步骤

### 第一阶段：数据探索 (2-3天)
1. 加载和了解数据
2. 探索性数据分析
3. 可视化数据分布
4. 识别数据质量问题

### 第二阶段：特征工程 (3-4天)
1. 数据清洗
2. 创建新特征
3. 特征选择
4. 数据预处理

### 第三阶段：模型开发 (4-5天)
1. 选择基准模型
2. 训练多个算法
3. 模型评估和比较
4. 超参数调优

### 第四阶段：应用开发 (3-4天)
1. 开发Streamlit应用
2. 添加预测功能
3. 用户界面优化
4. 部署和测试

### 第五阶段：报告和总结 (2天)
1. 撰写技术报告
2. 制作演示PPT
3. 总结经验教训
4. 提出改进建议

## 📊 评估指标说明

- **RMSE (Root Mean Square Error)**: 均方根误差，衡量预测误差
- **MAE (Mean Absolute Error)**: 平均绝对误差，直观的误差度量
- **R² (R-squared)**: 决定系数，模型解释方差的比例

## 🚀 部署说明

### 本地运行
```bash
# 安装依赖
pip install -r requirements.txt

# 运行应用
streamlit run app.py
```

### 在线部署
1. 上传代码到GitHub
2. 连接Streamlit Cloud
3. 自动部署

---

*通过完成这个项目，你将掌握完整的机器学习项目开发流程！*